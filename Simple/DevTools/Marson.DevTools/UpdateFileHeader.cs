// Copyright (c) 2015 Marson Software
// All rights reserved.
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Management.Automation;
using System.Text;
using System.Threading.Tasks;

namespace Marson.DevTools
{
    [Cmdlet(VerbsData.Update, "FileHeader")]
    public class UpdateFileHeader : Cmdlet
    {
        [Parameter]
        public string BaseDir { get; set; }

        [Parameter]
        public SwitchParameter Recursive { get; set; }

        [Parameter(HelpMessage ="Path to the file containing the header to put at the top of every file")]
        public string HeaderFile { get; set; }

        [Parameter(HelpMessage = "Replace header in files with the <autogenerated> element in comments.")]
        public SwitchParameter IncludeAutogenerated { get; set; }

        [Parameter(HelpMessage = "The wildcard search pattern used for determining which files are updated. Default is \"*.cs\"")]
        public string FileSearchPattern { get; set; } = "*.cs";

        [Parameter(HelpMessage = "Confirm every file change")]
        public SwitchParameter Confirm { get; set; }

        [Parameter(HelpMessage = "Comma separated list of file names to skip.")]
        public string SkipFiles { get; set; }

        protected override void ProcessRecord()
        {
            base.ProcessRecord();

            if (string.IsNullOrEmpty(BaseDir))
            {
                BaseDir = Environment.CurrentDirectory;
            }

            var skipFilesSet = new HashSet<string>(StringComparer.CurrentCultureIgnoreCase);
            if (SkipFiles != null)
            {
                foreach (var skipFile in SkipFiles.Split(','))
                {
                    skipFilesSet.Add(skipFile);
                }
            }

            var header = File.ReadAllLines(HeaderFile);

            SearchOption searchOption = Recursive ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly;
            foreach (var filePath in Directory.EnumerateFiles(BaseDir, FileSearchPattern, searchOption))
            {
                if (!skipFilesSet.Contains(Path.GetFileName(filePath)))
                {
                    if (ShouldProcess(filePath))
                    {
                        if (!Confirm || ShouldContinue("", ""))
                        {
                            UpdateFile(filePath, header);
                        }
                    }
                }
            }

        }

        private void UpdateFile(string filePath, string[] header)
        {
            var contents = File.ReadAllLines(filePath);
            int remainingIndex = FindRemainingIndex(contents);
            if (remainingIndex >= 0)
            {
                using (StreamWriter writer = new StreamWriter(filePath + ".out"))
                {
                    foreach (var line in header)
                    {
                        writer.WriteLine(line);
                    }
                    for (int i = remainingIndex; i < contents.Length; i++)
                    {
                        writer.WriteLine(contents[i]);
                    }
                }
                File.Delete(filePath);
                File.Move(filePath + ".out", filePath);
            }
        }

        private int FindRemainingIndex(string[] contents)
        {
            int index;

            // Ignore first whitespace lines
            for (index = 0; index < contents.Length && string.IsNullOrWhiteSpace(contents[index]); index++)
            {
            }

            if (index == contents.Length)
            {
                return -1;
            }

            // Skip existing comments except XML documentation comments
            string currentLine = contents[index];
            while (index < contents.Length && currentLine.StartsWith("//") && (currentLine.Length == 2 || currentLine[2] != '/'))
            {
                // Special case check: always skip autogenerated
                if (currentLine.Contains("<autogenerated>"))
                {
                    return -1;
                }
                index++;
                currentLine = contents[index];
            }

            if (index == contents.Length)
            {
                return -1;
            }
            return index;
        }
    }
}
